axis.line.x.bottom = element_line(size = .3, color = "black"),
axis.ticks = element_blank(),
panel.grid = element_line(linetype = "dashed")
)
# interaction plot
ggplot(dat_long, aes(x = condition, y = rt, shape = language, group = language, color = language)) +
stat_summary(fun = "mean", geom = "point", size = 3) +
stat_summary(fun = "mean", geom = "line") +
stat_summary(fun.data = "mean_se", geom = "errorbar", width = .2) +
scale_color_manual(
values = c("blue", "darkorange")
) +
theme_cowplot() +
theme(
axis.line = element_line(size = .3)
)
# combined interaction plot
p3 <- ggplot(dat_long, aes(x = condition, y = rt, shape = language, group = language)) +
geom_point(aes(color = language), alpha = .2) +
geom_line(aes(group = id, color = language), alpha = .2) +
stat_summary(fun = "mean", geom = "point", size = 2, color = "black") +
stat_summary(fun = "mean", geom = "line", color = "black") +
stat_summary(fun.data = "mean_se", geom = "errorbar", width = .2, color = "black") +
theme_cowplot() +
theme(
axis.line = element_line(size = .3)
)
# scatterplots
p1 <- ggplot(dat_long, aes(x = rt, y = age, color = condition)) +
geom_point() +
geom_smooth(method = "lm") +
scale_colour_discrete(
name = "Condition",
labels = c("Word", "Non-word")
) +
theme_cowplot() +
theme(
axis.line = element_line(size = .3)
) +
facet_wrap(~condition)
# grouped violin-boxplot
p2 <- ggplot(dat_long, aes(x = condition, y = rt, fill = language)) +
geom_violin(
alpha = .4
) +
geom_boxplot(
width = .2,
fatten = NULL,
position = position_dodge(.9),
alpha = .4
) +
stat_summary(fun = "mean", geom = "point", position = position_dodge(.9)) +
stat_summary(fun.data = "mean_se", geom = "errorbar", width = .1, position = position_dodge(.9)) +
scale_y_continuous(
expand = c(0, 0)
) +
scale_fill_viridis_d(
option = "E"
) +
theme_minimal_hgrid(
font_size = 11,
line_size = .3
) +
theme(
axis.line.x.bottom = element_line(size = .3, color = "black"),
axis.ticks = element_blank(),
panel.grid = element_line(linetype = "dashed")
) +
facet_wrap(~factor(language,
levels = c("monolingual", "bilingual"),
labels = c("Monolingual participants", "Bilingual participants")
)) +
guides(fill = FALSE) # remove legend
p2
# saving plots as images
# ggsave(filename = "grouped_violin_plots.png", plot = p1)
# arranging multiple plots
p1 + p2 # side-by-side
p1 / p2 # stacked
(p3 | p4) / p1 + p3 # multiple plots
# labeling axis with labs()
p3 + labs(
x = "Type of word",
y = "Reaction time (ms)",
title = "Language group by word type interaction plot",
subtitle = "Reaction time data"
)
theme_hgrid_config <- theme_minimal_hgrid(
font_size = 11,
line_size = .3
) +
theme(
axis.line.x.bottom = element_line(size = .3, color = "black"),
axis.ticks = element_blank(),
panel.grid = element_line(linetype = "dashed"))
# split-violin plots
ggplot(dat_long, aes(x = condition, y = rt, fill = language)) +
introdataviz::geom_split_violin(alpha = .4, trim = FALSE) +
geom_boxplot(width = .2, alpha = .6, show.legend = FALSE) +
stat_summary(fun.data = "mean_se", geom = "pointrange", show.legend = F,
position = position_dodge(.175)) +
scale_x_discrete(name = "Condition", labels = c("Non-word", "Word")) +
scale_y_continuous(name = "Reaction time (ms)",
breaks = seq(200, 800, 100),
limits = c(200, 800),
expand = c(0, 0)) +
scale_fill_viridis_d(option = "E", name = "Language group") +
theme_hgrid_config
# Raincloud plots
rain_height <- .1
ggplot(dat_long, aes(x = "", y = rt, fill = language)) +
# clouds
introdataviz::geom_flat_violin(trim=FALSE, alpha = 0.4,
position = position_nudge(x = rain_height+.05)) +
# rain
geom_point(aes(colour = language), size = 2, alpha = .5, show.legend = FALSE,
position = position_jitter(width = rain_height, height = 0)) +
# boxplots
geom_boxplot(width = rain_height, alpha = 0.4, show.legend = FALSE,
outlier.shape = NA,
position = position_nudge(x = -rain_height*2)) +
# mean and SE point in the cloud
stat_summary(fun.data = mean_se, mapping = aes(color = language), show.legend = FALSE,
position = position_nudge(x = rain_height * 3)) +
# adjust layout
scale_x_discrete(name = "", expand = c(rain_height*3, 0, 0, 0.7)) +
scale_y_continuous(name = "Reaction time (ms)",
breaks = seq(200, 800, 100),
limits = c(200, 800)) +
coord_flip() +
facet_wrap(~factor(condition,
levels = c("word", "nonword"),
labels = c("Word", "Non-Word")),
nrow = 2) +
# custom colours and theme
scale_fill_viridis_d(option = "E", name = "Language group") +
scale_colour_viridis_d(option  ="E") +
theme_minimal() +
theme(panel.grid.major.y = element_blank(),
legend.position = c(0.8, 0.8),
legend.background = element_rect(fill = "white", color = "white"),
panel.grid = element_line(linetype = "dashed"))
# Ridge plots
# read in data from Nation et al. 2017
data <- read_csv("https://raw.githubusercontent.com/zonination/perceptions/master/probly.csv")
# convert to long format and percents
long <- pivot_longer(data, cols = everything(),
names_to = "label",
values_to = "prob") %>%
mutate(label = factor(label, names(data), names(data)),
prob = prob/100)
# ridge plot
ggplot(long, aes(x = prob, y = label, fill = label)) +
ggridges::geom_density_ridges(scale = 2, show.legend = FALSE) +
scale_x_continuous(name = "Assigned Probability",
limits = c(0, 1.1), labels = scales::percent,
expand = c(0, 0)
) +
# control space at top and bottom of plot
scale_y_discrete(name = "", expand = c(0.02, 0, .08, 0)) +
theme_dviz_vgrid() +
theme(
panel.grid = element_line(size = .3, linetype = "dashed"),
panel.border = element_blank(),
axis.ticks.y = element_blank()
)
# Alluvial plots
# simulate data for 4 years of grades from 500 students
# with a correlation of 0.75 from year to year
# and a slight increase each year
dat <- faux::sim_design(
within = list(year = c("Y1", "Y2", "Y3", "Y4")),
n = 500,
mu = c(Y1 = 0, Y2 = .2, Y3 = .4, Y4 = .6), r = 0.75,
dv = "grade", long = TRUE, plot = FALSE) %>%
# convert numeric grades to letters with a defined probability
mutate(grade = faux::norm2likert(grade, prob = c("3rd" = 5, "2.2" = 10, "2.1" = 40, "1st" = 20)),
grade = factor(grade, c("1st", "2.1", "2.2", "3rd"))) %>%
# reformat data and count each combination
tidyr::pivot_wider(names_from = year, values_from = grade) %>%
dplyr::count(Y1, Y2, Y3, Y4)
# plot data with colours by Year1 grades
ggplot(dat, aes(y = n, axis1 = Y1, axis2 = Y2, axis3 = Y3, axis4 = Y4)) +
geom_alluvium(aes(fill = Y4), width = 1/6) +
geom_stratum(fill = "grey", width = 1/3, color = "black") +
geom_label(stat = "stratum", aes(label = after_stat(stratum))) +
scale_fill_viridis_d(name = "Final Classification") +
theme_minimal() +
theme(legend.position = "top")
mpg_sum <- mpg |>
dplyr::filter(year == 2008) |>
dplyr::mutate(
# capitalize first letter
manufacturer = stringr::str_to_title(manufacturer),
# turn into lumped factors with capitalized names
manufacturer = forcats::fct_lump(manufacturer, n = 10)
) |>
# count and sort ocurrences
dplyr::count(manufacturer, sort = TRUE) |>
dplyr::mutate(
#  order factor levels by number, put "Other" to end
manufacturer = forcats::fct_rev(forcats::fct_inorder(manufacturer)),
manufacturer = forcats::fct_relevel(manufacturer, "Other", after = 0)
)
# we have reversed the ordering since {ggplot2} plots factors from bottom to top when being mapped to y
mpg_sum
# plotting the basic bar plot
ggplot(mpg_sum, aes(x = n, y = manufacturer)) +
geom_col(fill = "gray70") +
theme_minimal()
# calculate percentages creating a temp df
# option 1: using sprintf() to create percentage labels
mpg_sum <- mpg_sum |>
dplyr::mutate(
perc = paste0(sprintf("%4.1f", n / sum(n) * 100), "%")
)
mpg_sum
# option 2: using the percent() from the scales package
# mpg_sum <- mpg_sum |>
#   dplyr::mutate(
#     perc = scales::percent(n / sum(n), accuracy = .1, trim = FALSE)
#   )
# mpg_sum
# adding the percentage label
ggplot(mpg_sum, aes(x = n, y = manufacturer)) +
geom_col(fill = "gray70") +
geom_text(aes(label = perc)) +
theme_minimal()
# adding some description to one of the bars
mpg_sum <- mpg_sum |>
dplyr::mutate(
perc = paste0(sprintf("%4.1f", n / sum(n) * 100), "%"),
perc = if_else(row_number() == 1, paste(perc, "of all car models"), perc)
)
ggplot(mpg_sum, aes(x = n, y = manufacturer)) +
geom_col(fill = "gray70") +
geom_text(aes(label = perc)) +
theme_minimal()
# example of creating and placing labels on the fly
# prepare non-aggregated data set with lumped and ordered factors
# mpg_fct <- mpg %>%
#   dplyr::filter(year == 2008) %>%
#   dplyr::mutate(
#     # add count to calculate percentages later
#     total = dplyr::n(),
#     # turn into lumped factors with capitalized names
#     manufacturer = stringr::str_to_title(manufacturer),
#     manufacturer = forcats::fct_lump(manufacturer, n = 10),
#     # order factor levels by number, put "Other" to end
#     manufacturer = forcats::fct_rev(forcats::fct_infreq(manufacturer)),
#     manufacturer = forcats::fct_relevel(manufacturer, "Other", after = 0)
#   )
# mpg_fct
#
# ggplot(mpg_fct, aes(x = manufacturer)) +
#   geom_bar(fill = "gray70") +
#   # add count labels
#   geom_text(
#     stat = "count",
#     aes(label = ..count..)
#   ) +
#   # rotate plot
#   coord_flip() +
#   theme_minimal()
# locating labels inside the bars
ggplot(mpg_sum, aes(x = n, y = manufacturer)) +
geom_col(fill = "gray70") +
geom_text(aes(label = perc),
hjust = 1,
nudge_x = -.5
) +
theme_minimal()
# In case you want to put the next to the bars, you often need to adjust the plot margin and/or the limits to avoid that the labels are cut off. The drawback of using limits is that you have to define them manually.You can make sure that labels are not truncated by the panel by adding clip = "off" to any coordinate system.
# adding colors to the bars using different hues
# option 1: create color palette based on input data
pal <- c(
"gray85",
# use the length of the manufacturer column for all non-highlighted bars and subtract the number of bars we want to highlight
rep("gray70", length(mpg_sum$manufacturer) - 4),
"coral2", "mediumpurple1", "goldenrod1"
)
ggplot(mpg_sum, aes(x = n, y = manufacturer, fill = manufacturer)) +
geom_col() +
geom_text(aes(label = perc),
hjust = 1,
nudge_x = -.5
) +
# add custom colors
scale_fill_manual(values = pal, guide = "none") +
theme_minimal()
# option 2: add the color to the data set and map the fill to that column and use scale_fill_identity()
# this option will work also if the data were updated!
mpg_sum <- mpg_sum  |>
mutate(
color = case_when(
row_number() == 1 ~ "goldenrod1",
row_number() == 2 ~ "mediumpurple1",
row_number() == 3 ~ "coral2",
manufacturer == "Other" ~ "gray85",
# all others should be gray
TRUE ~ "gray70"
)
)
ggplot(mpg_sum, aes(x = n, y = manufacturer, fill = color)) +
geom_col() +
geom_text(
aes(label = perc),
hjust = 1, nudge_x = -.5
) +
# add custom colors
scale_fill_identity(guide = "none") +
theme_minimal()
# some polishing
ggplot(mpg_sum, aes(x = n, y = manufacturer, fill = color)) +
geom_col() +
geom_text(
aes(label = perc),
hjust = 1, nudge_x = -.5,
size = 3.5, fontface = "bold", family = "Fira Sans"
) +
scale_x_continuous(expand = c(.01, .01)) +
# add custom colors
scale_fill_identity(guide = "none") +
theme_void() +
theme(
axis.text.y = element_text(size = 14, hjust = 1, family = "Fira Sans"),
plot.margin = margin(rep(15, 4))
)
# adding label boxes for accessibility
ggplot(mpg_sum, aes(x = n, y = manufacturer, fill = color)) +
geom_col() +
geom_label(
aes(label = perc),
hjust = 1, nudge_x = -.5,
size = 3.5, fontface = "bold", family = "Fira Sans",
fill = "white", label.size = 0
) +
scale_x_continuous(expand = c(.01, .01)) +
# add custom colors
scale_fill_identity(guide = "none") +
theme_void() +
theme(
axis.text.y = element_text(size = 14, hjust = 1, family = "Fira Sans"),
plot.margin = margin(rep(15, 4))
)
# with a different label placement
mpg_sum2 <- mpg_sum |>
mutate(
# set justification based on data
# so that only the first label is placed inside
place = if_else(row_number() == 1, 1, 0),
# add some spacing to labels since we cant use nudge_x anymore
perc = paste(" ", perc, " ")
)
mpg_sum2
ggplot(mpg_sum2, aes(x = n, y = manufacturer, fill = color)) +
geom_col() +
geom_text(
aes(label = perc, hjust = place),
size = 4, fontface = "bold", family = "Fira Sans"
) +
scale_x_continuous(expand = c(.01, .01)) +
scale_fill_identity(guide = "none") +
theme_void() +
theme(
axis.text.y = element_text(size = 14, hjust = 1, family = "Fira Sans"),
plot.margin = margin(rep(15, 4))
)
# create the wage_cat variable which takes two values
# such as Above if the wage is above median and Below if the wage is below median
Wage$wage_cat <- as.factor(ifelse(Wage$wage > median(Wage$wage), "Above", "Below"))
# Examine the Wage vs Job Class
# you could use also the command xtabs(~jobclass+wage_cat, data=Wage)
con1 <- table(Wage$jobclass, Wage$wage_cat)
con1
# the most proper way to represent graphically the contingency tables are the mosaic plots
mosaicplot(con1)
# we can get the proportions of the Contingency Tables, on overall and by rows and columns
# overall
prop.table(con1)
# by row
prop.table(con1, margin = 1)
# by column
prop.table(con1, margin = 2)
# we can add the rows and columns totals of the contingency tables as follows
addmargins(con1)
con4 <- xtabs(~ jobclass + wage_cat + race, data = Wage)
ftable(con4)
# let’s say that we want to change the share of the rows and columns
con4 |> ftable(row.vars = c("race", "jobclass"))
# let’s say now we want to get the probabilities by row
con4  |>
ftable(row.vars = c("race", "jobclass"))  |>
prop.table(margin = 1)  |>
round(2)
# build a table to compare the marginal frequencies
margins <- rbind(white = margin.table(con4,1), black = margin.table(con4,2))
names(dimnames(margins)) <- c("Race", "Jobclass")
margins
# representing one individual color
unikn::seecol(Seeblau)
# comparing two similar colors
unikn::seecol(c(Seeblau, "deepskyblue"))
# representing a color palette
unikn::seecol(pal = "pal_seeblau", n = 5)
# representing unikn color palettes
unikn::seecol(pal = "unikn_all")
# defining Brew palettes
brew_1 <- brewer.pal(n = 10, name = "Set1")
brew_2 <- brewer.pal(n = 10, name = "Set2")
brew_Accent <- brewer.pal(n = 10, name = "Accent")
brew_Dark2 <- brewer.pal(n = 8, name = "Dark2")
brew_greens <- brewer.pal(n = 9, name = "Greens")
brew_blues <- brewer.pal(n = 9, name = "Blues")
brew_reds <- brewer.pal(n = 9, name = "Reds")
brew_oranges <- brewer.pal(n = 9, name = "Oranges")
brew_Paired <- brewer.pal(n = 12, name = "Paired")
brew_Spectral <- brewer.pal(n = 11, name = "Spectral")
# Qualitative color palettes
unikn::seecol(pal = list(pal_unikn_pref, pal_unikn_light, pal_unikn_dark, pal_signal, brew_1, brew_2, brew_Accent, brew_Dark2), pal_names = c("pal_unikn_pref", "pal_unikn_light", "pal_unikn_dark", "pal_signal", "brew_Set1", "brew_Set2", "brew_Accent", "brew_Dark2"), title = "Qualitative color palettes", lwd_brd = 4)
# Sequential color palettes
unikn::seecol(pal = list(pal_seeblau, pal_pinky,  pal_seegruen, pal_bordeaux, brew_greens, brew_reds, brew_blues, brew_oranges), pal_names = c("pal_seeblau", "pal_pinky", "pal_seegruen", "pal_bordeaux", "brew_greens", "brew_reds", "brew_blues", "brew_oranges"), n = 5, title = "Sequential color palettes (n = 5)", lwd_brd = 4)
# Diverging color palettes
# defining palettes
unikn_1 <- c(rev(pal_seeblau), "white", pal_pinky)
unikn_2 <- c(rev(pal_peach), "white", pal_seegruen)
unikn_3 <- c(rev(pal_petrol), "white", pal_bordeaux)
unikn_4 <- c(rev(pal_pinky), "white", pal_karpfenblau)
brew_1 <- brewer.pal(n = 11, name = "Spectral")
brew_2 <- brewer.pal(n = 11, name = "RdYlBu")
brew_3 <- brewer.pal(n = 11, name = "PuOr")
brew_4 <- brewer.pal(n = 11, name = "BrBG")
unikn::seecol(pal = list(unikn_1, unikn_2, unikn_3, unikn_4, brew_1, brew_2, brew_3, brew_4), pal_names = c("unikn_1", "unikn_2", "unikn_3", "unikn_4", "brew_1", "brew_2", "brew_3", "brew_4"), title = "Diverging color palettes (n = 11)", lwd_brd = 4)
# Hybrid color palettes
# Paired color palettes
unikn::seecol(pal = list(brew_Paired, pal_unikn_pair), pal_names = c("brew_Paired", "pal_unikn_pair"), title = "Paired color scales", lwd_brd = 2)
# Sequential color palettes
# defining palettes
unikn_1s <- c("pink3", pal_grau)
unikn_2s <- c("yellow2", pal_seeblau)
unikn_3s <- c("purple3", pal_bordeaux)
unikn_4s <- c("violetred4", pal_karpfenblau)
brew_Spectrals <- brewer.pal(n = 8, name = "Spectral")
unikn::seecol(pal = list(unikn_1s, unikn_2s, unikn_3s, unikn_4s, brew_Accent, brew_Spectrals), pal_names = c("unikn_1", "unikn_2", "unikn_3", "unikn_4", "brew_Accent", "brew_Spectral"), title = "Qualitative color palettes with accent colors", lwd_brd = 4)
# Base R color functions
n <- 10
p1 <- cm.colors(n)
p2 <- rainbow(n)
p3 <- heat.colors(n)
p4 <- terrain.colors(n)
p5 <- topo.colors(n)
# Example plots:
pie(rep(1, n), col = p2, main = "Pie plot with rainbow(n = 10)")
barplot(seq(1:n), col = p4, main = "Bar plot with terrain.colors(n = 10)")
# HCL color palettes
# the 110 HCL color palettes (in the grDevices of R)
colorspace::hcl_palettes(plot = TRUE)
n <- 10
h1 <- hcl.colors(n, palette = "Dynamic")
h2 <- hcl.colors(n, palette = "Earth")
h3 <- hcl.colors(n, palette = "Berlin")
h4 <- hcl.colors(n, palette = "Fall")
h5 <- hcl.colors(n, palette = "Sunset")
# Example hcl palettes
unikn::seecol(list(h1, h2, h3, h4, h5),
col_brd = "white", lwd_brd = 4,
title = "Example palettes from hcl.colors(n = 10)",
pal_names = c("Dynamic", "Earth", "Berlin", "Fall", "Sunset")
)
# types of hcl palettes
colorspace::hcl_palettes("qualitative", plot = TRUE)
colorspace::hcl_palettes("diverging", n = 5, plot = TRUE)
colorspace::divergingx_palettes(n = 5, plot = TRUE)
colorspace::hcl_palettes("sequential", n = 5, plot = TRUE)
# palettes for color vision deficiencies
# color blind friendly palette (with grey):
cbf_1 <- c("#999999", "#E69F00", "#56B4E9", "#009E73",
"#F0E442", "#0072B2", "#D55E00", "#CC79A7")
# color_blind_friendly palette (with black):
cbf_2 <- c("#000000", "#E69F00", "#56B4E9", "#009E73",
"#F0E442", "#0072B2", "#D55E00", "#CC79A7")
unikn::seecol(list(cbf_1, cbf_2), pal_names = c("cbf_1", "cbf_2"), title = "Two color friendly color palettes", lwd_brd = 2)
# RColorBrewer
# print all color palettes
RColorBrewer::display.brewer.all()
# viridis/viridisLite
# Example1
vir_10 <- viridis(n = 10)
seecol(vir_10,
col_brd = "white", lwd_brd = 4,
title = "Example of a viridis color palette (n = 10)",
pal_names = paste0("viridis_", 1:10)
)
# Example2
n <- 20
v1 <- viridis(n)
v2 <- magma(n)
v3 <- inferno(n)
v4 <- plasma(n)
v5 <- cividis(n)
seecol(list(v1, v2, v3, v4, v5),
col_brd = "white", lwd_brd = 4,
title = "Various viridis color palettes (n = 20)",
pal_names = c("v1: viridis", "v2: magma", "v3: inferno", "v4: plasma",  "v5: cividis"))
# lintr::lint("main.Rmd", linters =
#               lintr::with_defaults(
#                 commented_code_linter = NULL,
#                 trailing_whitespace_linter = NULL
#                 )
#             )
# # if you have additional scripts and want them to be linted too, add them here
# lintr::lint("scripts/my_script.R")
