# add PCs to the original dataset
augment(blue_jays) %>%
ggplot(aes(.fittedPC1, .fittedPC2)) +
geom_point(aes(color = sex))
# Plot PC 2 against PC 1
pca_fit %>%
# add PCs to the original dataset
augment(blue_jays) %>%
ggplot(aes(.fittedPC1, .fittedPC2)) +
geom_point(aes(color = sex))
# Plot PC 3 against PC 2
pca_fit %>%
# add PCs to the original dataset
augment(blue_jays) %>%
ggplot(aes(.fittedPC2, .fittedPC3)) +
geom_point(aes(color = sex))
# Plot the rotation matrix
arrow_style <- arrow(
angle = 20, length = grid::unit(8, "pt"),
ends = "first", type = "closed"
)
pca_fit %>%
# extract rotation matrix
tidy(matrix = "rotation") %>%
pivot_wider(
names_from = "PC", values_from = "value",
names_prefix = "PC"
) %>%
ggplot(aes(PC1, PC2)) +
geom_segment(
xend = 0, yend = 0,
arrow = arrow_style
) +
geom_text(aes(label = column), hjust = 1) +
xlim(-1.5, 0.5) + ylim(-1, 1) +
coord_fixed()
# Plot the variance explained
pca_fit %>%
# extract eigenvalues
tidy(matrix = "eigenvalues") %>%
ggplot(aes(PC, percent)) +
geom_col() +
scale_x_continuous(
# create one axis tick per PC
breaks = 1:6
) +
scale_y_continuous(
name = "variance explained",
# format y axis ticks as percent values
label = scales::label_percent(accuracy = 1)
)
ggplot(iris, aes(Petal.Length, Petal.Width, color = Species)) +
geom_point()
# We perform k-means clustering with kmeans()
km_fit <- iris %>%
select(where(is.numeric)) %>%
kmeans(
centers = 3,  # number of cluster centers
nstart = 10   # number of independent restarts of the algorithm
)
km_fit
# data
texas_income <- readRDS("input/Texas_income.rds")
ggplot(texas_income) +
geom_sf()
# plot only Travis County
texas_income %>%
filter(county == "Travis") %>%
ggplot() +
geom_sf()
# plot the ten richest counties
texas_income %>%
slice_max(median_income, n = 10) %>%
ggplot() +
geom_sf()
# color counties by median income
texas_income %>%
ggplot(aes(fill = median_income)) +
geom_sf()
# highlight the ten richest counties
texas_income %>%
mutate(
top_ten = rank(desc(median_income)) <= 10
) %>%
ggplot(aes(fill = top_ten)) +
geom_sf(color = "black", size = 0.1) +
scale_fill_manual(
name = NULL,
values = c(
`TRUE` = "#D55E00",
`FALSE` = "#E8EEF9"
),
breaks = c(TRUE),
labels = "top-10 median income"
) +
theme_minimal_grid(11)
ggplot(texas_income) +
geom_sf(
aes(fill = median_income),
color = "black", size = 0.1
) +
colorspace::scale_fill_continuous_sequential(
palette = "Blues", rev = TRUE
) +
theme_minimal_grid(11)
# We can customize the projection with coord_sf()
ggplot(texas_income) +
geom_sf(
aes(fill = median_income),
color = "black", size = 0.1
) +
colorspace::scale_fill_continuous_sequential(
palette = "Blues", rev = TRUE
) +
coord_sf(
# Texas Centric Albers Equal Area
crs = 3083
) +
theme_minimal_grid(11)
ggplot(texas_income) +
geom_sf(
aes(fill = median_income),
color = "black", size = 0.1
) +
colorspace::scale_fill_continuous_sequential(
palette = "Blues", rev = TRUE
) +
coord_sf(
# Texas Centric Lambert Conformal Conic
crs = 32139
) +
theme_minimal_grid(11)
ggplot(texas_income) +
geom_sf(
aes(fill = median_income),
color = "black", size = 0.1
) +
colorspace::scale_fill_continuous_sequential(
palette = "Blues", rev = TRUE
) +
coord_sf(
# Web Mercator (Google Maps)
crs = 3857
) +
theme_minimal_grid(11)
# all data
tech_stocks <- read_csv("input/tech_stocks.csv") %>%
mutate(date = ymd(date))
# Most recent values only
tech_stocks_last <- tech_stocks %>%
filter(date == max(date))
tech_stocks_last
# Secondary axis trick
ggplot(tech_stocks) +
aes(x = date, y = price_indexed) +
geom_line(aes(color = company), na.rm = TRUE) +
scale_x_date(
limits = c(
ymd("2012-06-01"),
ymd("2017-05-31")
),
expand = c(0, 0)
) +
scale_y_continuous(
limits = c(0, 560),
expand = c(0, 0),
sec.axis = dup_axis(
breaks = tech_stocks_last$price_indexed,
labels = tech_stocks_last$company,
name = NULL
)
) +
guides(color = "none")
# Manual labeling with geom_text()
# Manually create table with label positions
iris_labels <- tibble(
Species = c("setosa", "virginica", "versicolor"),
Sepal.Width = c(4.2, 3.76, 2.08),
Sepal.Length = c(5.7, 7, 5.1),
label = c("Iris setosa", "Iris virginica", "Iris versicolor"),
hjust = c(0, 0.5, 0),
vjust = c(0, 0.5, 1)
)
iris_labels
# And plotting
ggplot(iris) +
aes(Sepal.Length, Sepal.Width, color = Species) +
geom_point(aes(shape = Species)) +
geom_text(
data = iris_labels,
aes(
label = label,
hjust = hjust, vjust = vjust
),
size = 14/.pt # 14pt font
) +
stat_ellipse(size = 0.5) + # add ellipses
guides(color = "none", shape = "none")
# Automatic labeling with geom_text_repel()
mtcars_named <- mtcars %>%
rownames_to_column("car") %>% # rownames to column car
select(car, weight = wt, mpg)
mtcars_named
ggplot(mtcars_named, aes(weight, mpg)) +
geom_point() +
geom_text_repel(
aes(label = car),
max.overlaps = Inf
)
set.seed(42)
mtcars_named %>%
mutate(
# randomly exclude 50% of the labels
car = ifelse(runif(n()) < 0.5, "", car)
) %>%
ggplot(aes(weight, mpg)) +
geom_point() +
geom_text_repel(
aes(label = car),
max.overlaps = Inf,
box.padding = 0.7 # controls how far labels are placed from data points
)
# hovering displays species names
# iris_scatter <- ggplot(iris) +
#   aes(
#     Sepal.Length, Sepal.Width,
#     color = Species
#   ) +
#   geom_point_interactive(
#     aes(tooltip = Species)
#   )
#
# girafe(
#   ggobj = iris_scatter,
#   width_svg = 6,
#   height_svg = 6*0.618
# )
#
# # Styling happens via Cascading Style Sheets (CSS)
# girafe(
#   ggobj = iris_scatter,
#   width_svg = 6,
#   height_svg = 6*0.618,
#   options = list(
#     opts_tooltip(
# css = "background: #F5F5F5; color: #191970;"
#     )
#   )
# )
#
# # Select multiple points at once with data_id aesthetic
# iris_scatter <- ggplot(iris) +
#   aes(
#     Sepal.Length, Sepal.Width,
#     color = Species
#   ) +
#   geom_point_interactive(
#     aes(data_id = Species),
#     size = 2
#   )
#
# girafe(
#   ggobj = iris_scatter,
#   width_svg = 6,
#   height_svg = 6*0.618
# )
#
# # Via CSS
# girafe(
#   ggobj = iris_scatter,
#   width_svg = 6,
#   height_svg = 6*0.618,
#   options = list(
#     opts_hover(css = "fill: #202020;"),
#     opts_hover_inv(css = "opacity: 0.2;")
#   )
# )
#
# # Interactive map example
# # load data
# US_states <- readRDS(url("https://wilkelab.org/SDS375/datasets/US_states.rds"))
# US_states
#
# # plotting
# US_map <- US_states %>%
#   ggplot() +
#   geom_sf_interactive(
#     aes(data_id = name, tooltip = name)
#   ) +
#   theme_void()
#
# girafe(
#   ggobj = US_map,
#   width_svg = 6,
#   height_svg = 6*0.618
# )
#
# # Click to open a state's wikipedia page
# US_map <- US_states %>%
#   mutate( # JavaScript call to open website
#     onclick = glue::glue(
# 'window.open(
# "https://en.wikipedia.org/wiki/{name}")')
#   ) %>%
#   ggplot() +
#   geom_sf_interactive(
#     aes(
#       data_id = name, tooltip = name,
#       onclick = onclick
#     )
#   ) +
#   theme_void()
#
# girafe(
#   ggobj = US_map,
#   width_svg = 6,
#   height_svg = 6*0.618
# )
# Contour lines
blue_jays %>%
ggplot(aes(body_mass_g, head_length_mm)) +
geom_density_2d() +
geom_point() +
theme_bw(14)
blue_jays %>%
ggplot(aes(body_mass_g, head_length_mm)) +
geom_density_2d(bins = 5) +
geom_point() +
theme_bw(14)
ggplot(blue_jays, aes(body_mass_g, head_length_mm)) +
geom_density_2d_filled(bins = 5, alpha = 0.5) +
geom_density_2d(bins = 5, color = "black", size = 0.2) +
geom_point() +
theme_bw(14)
# 2D histograms
ggplot(blue_jays, aes(body_mass_g, head_length_mm)) +
geom_bin2d() +
theme_bw(14)
ggplot(blue_jays, aes(body_mass_g, head_length_mm)) +
geom_bin2d(binwidth = c(3, 3)) +
theme_bw(14)
ggplot(blue_jays, aes(body_mass_g, head_length_mm)) +
geom_bin2d(binwidth = c(1, 5)) +
theme_bw(14)
ggplot(blue_jays, aes(body_mass_g, head_length_mm)) +
geom_bin2d(binwidth = c(5, 1)) +
theme_bw(14)
# Hex bins
ggplot(blue_jays, aes(body_mass_g, head_length_mm)) +
geom_hex() +
theme_bw(14)
ggplot(blue_jays, aes(body_mass_g, head_length_mm)) +
geom_hex(bins = 15) +
theme_bw(14)
ggplot(blue_jays, aes(body_mass_g, head_length_mm)) +
geom_hex(bins = 10) +
theme_bw(14)
# The patchwork package#
# make first plot
p1 <- ggplot(mtcars) +
geom_point(aes(mpg, disp))
# make second plot
p2 <- ggplot(mtcars) +
aes(gear, disp, group = gear) +
geom_boxplot()
# place plots side-by-side
p1 | p2
# make first plot
p1 <- ggplot(mtcars) +
geom_point(aes(mpg, disp))
# make second plot
p2 <- ggplot(mtcars) +
aes(gear, disp, group = gear) +
geom_boxplot()
# place plots side-by-side
p1 | p2
# make first plot
p1 <- ggplot(mtcars) +
geom_point(aes(mpg, disp))
# make second plot
p2 <- ggplot(mtcars) +
aes(gear, disp, group = gear) +
geom_boxplot()
# place plots on top of one-another
p1 / p2
# add a few more plots
p3 <- ggplot(mtcars) +
geom_smooth(aes(disp, qsec))
p4 <- ggplot(mtcars) +
geom_bar(aes(carb))
# make complex arrangement
(p1 | p2 | p3) / p4
# Plot annotations and themes
(p1 | p2 | p3) / p4 +
plot_annotation(
tag_levels = "a"
)
(p1 | p2 | p3) / p4 +
plot_annotation(
tag_levels = "a"
) &
theme_minimal_grid()
(p1 | p2 | p3) / p4 +
plot_annotation(
tag_levels = "a",
title = "A plot about mtcars",
subtitle = "With subtitle...",
caption = "...and caption"
) &
theme_minimal_grid()
# Avoid hard-coding specific values
penguins %>%
filter(species == "Gentoo") %>%
ggplot() +
aes(bill_length_mm, body_mass_g) +
geom_point() +
ggtitle("Species: Gentoo") +
xlab("bill length (mm)") +
ylab("body mass (g)") +
theme_minimal_grid() +
theme(plot.title.position = "plot")
# species = "Adelie" # value
# species = "Chinstrap" # value
species = "Gentoo" # value
penguins %>%
filter(.data$species == .env$species) %>% #.data = column in df
ggplot() +                                #.env var en local env
aes(bill_length_mm, body_mass_g) +
geom_point() +
ggtitle(glue("Species: {species}")) +
xlab("bill length (mm)") +
ylab("body mass (g)") +
theme_minimal_grid() +
theme(plot.title.position = "plot")
# Define a function
make_plot <- function(species) {
penguins %>%
filter(.data$species == .env$species) %>%
ggplot() +
aes(bill_length_mm, body_mass_g) +
geom_point() +
ggtitle(glue("Species: {species}")) +
xlab("bill length (mm)") +
ylab("body mass (g)") +
theme_minimal_grid() +
theme(plot.title.position = "plot")
}
make_plot("Adelie")
make_plot("Chinstrap")
make_plot("Gentoo")
# Automate calling the function
species <- c("Adelie", "Chinstrap", "Gentoo")
plots <- map(species, make_plot) # map takes each element of the vector species and uses it as input for make_plot()
# It returns a list of created plots:
plots[[1]]
plots[[2]]
plots[[3]]
# `walk()` is like `map()` but doesn't return a value
# we use it only for side effects (such as printing)
walk(plots, print)
# Write a more general function
make_plot <- function(species) {
penguins %>% # hard-coded dataset!
filter(.data$species == .env$species) %>%
ggplot() +
aes(bill_length_mm, body_mass_g) +
geom_point() +
ggtitle(glue("Species: {species}")) +
xlab("bill length (mm)") +
ylab("body mass (g)") +
theme_minimal_grid() +
theme(plot.title.position = "plot")
}
make_plot2 <- function(data, species) {
data %>%
# filter no longer needed
ggplot() +
aes(bill_length_mm, body_mass_g) +
geom_point() +
ggtitle(glue("Species: {species}")) +
xlab("bill length (mm)") +
ylab("body mass (g)") +
theme_minimal_grid() +
theme(plot.title.position = "plot")
}
data_adelie <- penguins %>%
filter(species == "Adelie")
make_plot2(data_adelie, species = "Adelie")
# Use these concepts in a tidy pipeline
penguins %>%
nest(data = -species) %>%
mutate(plots = map2(data, species, make_plot2)) %>% # map2() is like map() but for functions with 2 arguments
pull(plots) %>%
walk(print)
# p <- ggplot(iris, aes(x = Petal.Width, y = Petal.Length)) +
#   geom_point()
# p
#
# anim <- p +
#   transition_states(Species,
#                     transition_length = 2,
#                     state_length = 1)
#
# anim
# lintr::lint("main.Rmd", linters =
#               lintr::with_defaults(
#                 commented_code_linter = NULL,
#                 trailing_whitespace_linter = NULL
#                 )
#             )
# # if you have additional scripts and want them to be linted too, add them here
# lintr::lint("scripts/my_script.R")
